# -*- coding: utf-8 -*-
"""Copy_of_QuantumML2dPointSetRegistration.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ap46mXtdBC-uz9_c8FFl7FTj9C2UPvT4

First import all necessay libraries
"""


# Commented out IPython magic to ensure Python compatibility.
# %pip install plyfile

import torch
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Tuple
import math
import random
import torch.nn as nn
import torch.nn.functional as F
from sklearn.neighbors import NearestNeighbors
from torch.utils.data import DataLoader
from torch.optim import Adam, AdamW
from scipy.linalg import block_diag
from scipy.ndimage.filters import gaussian_filter

from plyfile import PlyData, PlyElement
import glob
import os
import sys

BATCH_SIZE = 32
EPOCHS = 20
TOTAL_RESULT_VECTOR = 9

sigma_ls = [0.0,0.25,0.75]
#sigma = sigma_ls[int(sys.argv[1])-1]
sigma = 0.0
"""The return matrix is a simple rotational matrix defined like [here](https://en.wikipedia.org/wiki/Rotation_matrix). The angle $\theta \in [0,2\pi]$ is mapped to the set of $\{0, \dots, 2^9 - 1\}$ Here $\pi$ will be mapped to 0. Every angle between $\pi$ and $0$ will have values with a leading 0 and every angle between $\pi$ and $2 \pi$ will have a leading 1"""

def map_angle_to_bit_and_rotMat2(angle, pot):
  k = (1/3)*np.pi / ((2**pot) - 1)
  x = int(math.floor(angle / k))
  #total = 2**9 
  #before = [0] * (total - x - 1)
  #after = [0] * (x)
  return_angle = x #np.array(before + [1] + after)
  return_mat = np.array([[np.cos(angle), -np.sin(angle)],[np.sin(angle), np.cos(angle)]])
  return (return_angle, return_mat)

"""The generated point could will be normally distributed around the origin with $m$ points"""

def get_pointcloud_from_image(fileName):
  ply_file = PlyData.read(fileName)
  data = ply_file.elements[0].data
  ls = []
  for n in data:
    ls.append(list(n)[:2])
  return np.array(ls)

def gen_random_image():
  size = np.random.randint(low = 20, high = 2000)
  #size = 30
  return np.random.uniform(low = -1, high = 1, size = (size,2))

def Qk(k):
  # here probably still a bug from the paper, as there are two 0.1 ? 
  omegals = [0.5, 0.2, 0.1, 0.1, 0.05]
  I = np.identity(2)
  M = np.array([[0,-1], [1,0]])
  Cls = [I,M,-I,-M]
  i = int(k / 5)
  j = k % 5
  return omegals[j] * Cls[i]

ls = [Qk(i) for i in range(20)]
ls = np.array(ls)
basis = block_diag(*ls)
Q_ls = ls

number_of_NN = 10

def phiN(yns, x_row):
  size1 = yns.shape[0] # number of points
  size2 = yns.shape[1] # number of NN
  size3 = yns.shape[2] # dimension of PC
  phi = np.zeros((len(Q_ls), size1 * size2 * size3))
  for i in range(size1):
    phi_n = np.zeros((len(Q_ls), size2 * 2))
    for j in range(size2):
      current_point = yns[i,j,:]
      ls = []
      for bMat in Q_ls:
        ls.append(-(bMat @ current_point).T)
      ls = np.array(ls)
      phi_n[:,2*j:2*(j+1)] += ls
      #print(phi_n)
      #print('-----------')
    phi[:,i*size2*size3:(i+1)*size2*size3] += phi_n
  mat = np.concatenate((x_row,phi))
  return mat

def genA(P,H): 
  x_row = np.zeros((1,P.shape[1]*number_of_NN*2))
  for i in range(P.shape[1]):
    for j in range(number_of_NN):
      x_row[0,i*2 * number_of_NN + j*2:i*2*number_of_NN+(j+1)*2] = P[:,i]
  nbrs = NearestNeighbors(n_neighbors=number_of_NN).fit(P.T)
  _, indices = nbrs.kneighbors(H.T)
  #indices = [[i] for i in range(91)]
  ybags = H.T[indices]
  phi = phiN(ybags,x_row)
  A = phi @ np.transpose(phi)
  return A

"""In order to generate the dataset we will randomly generate the point cloud and rotate it with a random angle n times. This product $H^T P$ will then be saved as a vector as well as the angle in bits"""

def gen_image_data(n, pot, from_, to_, myFiles):
  image_ls = []

  for filename in myFiles:
    x_coord = []
    y_coord = []
    with open(filename, 'r') as f: # open in readonly mode
      data = f.readlines()
      data = data[1:]
      read_hash = False
      for d in data:
        ls = d.split(' ')
        read_hash = '#' in ls or read_hash
        if not read_hash:
          x_coord.append(float(ls[0]))
          y_coord.append(float(ls[1]))
    img = np.array([x_coord, y_coord])
    image_ls.append(img.T) 
  
  ls = image_ls[from_:to_]
  for s in ls:
    P = s
    mean = P.mean(axis = 0)
    P -= mean
    scale = 1 / P.std(axis = 0) 
   
    P = scale * P
    number_of_rows = P.shape[0]
  
    for _ in range(n):
      angle = (1/3)*np.pi*random.uniform(0,1) # just have here +- 15 degree
      bin_ang, rot_mat = map_angle_to_bit_and_rotMat2(angle, pot)
      H = np.transpose(np.matmul(rot_mat, P.transpose()))
      H  = gaussian_filter(H, sigma=sigma)

      A = genA(P.T,H.T)
      dic['Input'].append(np.array(A.flatten(), dtype='f'))
      dic['Output'].append(bin_ang)
  df = pd.DataFrame(dic)
  df = df.sample(frac=1).reset_index(drop=True)
  return df

class Dataset(torch.utils.data.Dataset):
  'Characterizes a dataset for PyTorch'
  def __init__(self, dataFrame):
        'Initialization'
        self.df = dataFrame

  def __len__(self):
        'Denotes the total number of samples'
        return len(self.df.index)

  def __getitem__(self, index):
        'Generates one sample of data'
        # Select sample
        X = self.df['Input'][index]
        y = self.df['Output'][index]
        return X, y
        
os.chdir(r'') # directory, where the dataset is stored
myFiles = glob.glob('*.txt')
dic = {'Input' : [], 'Output' : []}
random.shuffle(myFiles)
myFiles.sort()
myFiles = [i for i in myFiles if not ('device-8' in i)]

number_f = 500
i = int(sys.argv[-1])
index = int((i-1) * ((number_f-20) / 15))
index_2 =int((i) * ((number_f-20) / 15))
df = gen_image_data(1000, 9, index, index_2, myFiles)
os.chdir(r'') # directory, where the processed data should be stored
pd.to_pickle(df, '60_deg_small_angle_data_2' + str(i))
number_f = 500
i = int(sys.argv[-1])
index = 300
index_2 =330
df = gen_image_data(1000, 9, index, index_2, myFiles)
os.chdir(r'') # directory, where the processed data should be stored
pd.to_pickle(df, 'eval_df')